<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>infiwrite</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=PT+Serif+Caption:ital@0;1&display=swap" rel="stylesheet">
    <style>
        /* Basic reset and body styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
            background-color: #1a1a1a; /* Dark background */
            color: #e0e0e0; /* Light text color */
            font-family: 'PT Serif Caption', serif; /* Apply the font */
            overflow: hidden; /* Prevent body scroll, editor handles scroll */
            position: relative; /* Needed for the noise pseudo-element */
        }

        /* Noise texture overlay */
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml,\
                <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">\
                <filter id="noise">\
                    <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch"/>\
                </filter>\
                <rect width="100%" height="100%" filter="url(%23noise)" opacity="0.05"/>\
                </svg>');
            pointer-events: none;
            z-index: -1;
            opacity: 0.5;
        }

        /* Main container */
        .container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 5vh 5vw;
            overflow-y: auto;
        }

        /* Editable area */
        #editor {
            width: 100%;
            max-width: 80ch;
            min-height: 90vh;
            font-size: 18px;
            line-height: 1.6;
            text-align: left;
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            caret-color: #e0e0e0;
        }

        /* Strikethrough style */
        #editor del {
            color: #888;
            text-decoration: line-through;
            text-decoration-color: #aaa;
        }

        /* Placeholder */
        #editor:empty::before {
            content: "Start typing here... (Ctrl/Cmd+S to Save)";
            color: #555;
            pointer-events: none;
            display: block;
            text-align: center;
            padding-top: 30vh;
        }
        #editor:focus::before {
             content: "";
         }
    </style>
</head>
<body>
    <div class="container">
        <div id="editor" contenteditable="true" spellcheck="false"></div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const localStorageKey = 'noiseEditorContent';
        let lastBackspaceTime = 0;
        const doublePressThreshold = 500;

        window.onload = () => {
            const savedContent = localStorage.getItem(localStorageKey);
            if (savedContent) {
                editor.innerHTML = savedContent;
            }
        };

        function saveTextToFile() {
            console.log("Save function triggered.");
            try {
                const textContent = editor.textContent || '';
                const baseFilename = document.title || 'notes';
                const filename = `${baseFilename.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`;
                const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setTimeout(() => URL.revokeObjectURL(url), 100);
                console.log(`Content prepared for saving as ${filename}`);
            } catch (e) {
                console.error("Error saving file:", e);
                alert("Could not save the file due to an error.");
            }
        }

        // --- Handle Keydown Events ---
        editor.addEventListener('keydown', function(event) {

            // --- Save Shortcut ---
            if ((event.ctrlKey || event.metaKey) && (event.key === 's' || event.key === 'S')) {
                event.preventDefault();
                saveTextToFile();
                lastBackspaceTime = 0;
                return;
            }

            // --- Prevent Delete ---
            if (event.key === 'Delete' || event.keyCode === 46) {
                 event.preventDefault();
                 console.log("Delete key prevented.");
                 lastBackspaceTime = 0;
                 return;
            }

            // --- Handle Backspace ---
            if (event.key === 'Backspace' || event.keyCode === 8) {
                event.preventDefault();

                const currentTime = Date.now();
                const isDoublePress = (currentTime - lastBackspaceTime) < doublePressThreshold;

                if (isDoublePress) {
                    console.log("Double Backspace detected.");
                    try {
                        const selection = window.getSelection();
                        if (selection && selection.rangeCount > 0 && selection.isCollapsed) {
                            const range = selection.getRangeAt(0);
                            let container = range.startContainer;
                            let offset = range.startOffset;

                            let targetContainer = null;
                            let targetOffset = 0;

                            // --- MODIFICATION START: Find Target Node using TreeWalker ---
                            console.log(`Initial check: Container=${container.nodeName}, Offset=${offset}, Type=${container.nodeType}`);

                            if (container.nodeType === Node.TEXT_NODE && offset > 0) {
                                // Standard case: Cursor is within a text node with content before it.
                                targetContainer = container;
                                targetOffset = offset;
                                console.log("Mode 1: Cursor within text node.");
                            } else {
                                // Case: Cursor is at offset 0 or not in a text node.
                                // We need to find the last text node *before* the current cursor position.
                                console.log("Mode 2: Cursor at offset 0 or not in text. Searching backwards...");

                                // Create a TreeWalker to iterate through text nodes within the editor
                                const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
                                let currentNode = null;
                                let lastValidNodeBeforeCursor = null;

                                // Iterate through all text nodes from the beginning
                                while ((currentNode = walker.nextNode())) {
                                    // Create a range representing the end of the current node being checked
                                    const nodeEndRange = document.createRange();
                                    try {
                                        nodeEndRange.selectNodeContents(currentNode);
                                        nodeEndRange.collapse(false); // Collapse to the end point
                                    } catch(e) {
                                        console.warn("Could not select node contents, skipping node:", currentNode, e);
                                        continue; // Skip this node if selection fails
                                    }


                                    // Compare the cursor position (range.start) with the end of the current node
                                    // range.compareBoundaryPoints returns:
                                    // -1 if range start is BEFORE nodeEndRange start
                                    //  0 if they are the same
                                    //  1 if range start is AFTER nodeEndRange start
                                    // We want nodes that END before or exactly at the cursor position.
                                    if (range.compareBoundaryPoints(Range.START_TO_END, nodeEndRange) >= 0) {
                                        // Check if the node has actual content (not just whitespace)
                                        if (/\S/.test(currentNode.textContent || '')) {
                                            // This node ends before or at the cursor, and has content. It's our current best candidate.
                                            lastValidNodeBeforeCursor = currentNode;
                                            // console.log(`Candidate node found: "${lastValidNodeBeforeCursor.textContent.slice(-20)}"`);
                                        }
                                    } else {
                                        // We've found a node that ends *after* the cursor position.
                                        // This means the previous candidate (`lastValidNodeBeforeCursor`) was the correct one.
                                        // console.log("Node ends after cursor, stopping search.");
                                        break;
                                    }
                                }

                                // Use the last valid node found
                                if (lastValidNodeBeforeCursor) {
                                    targetContainer = lastValidNodeBeforeCursor;
                                    targetOffset = targetContainer.textContent?.length || 0; // Target the end of this node
                                    console.log(`Found preceding text node via TreeWalker: "${targetContainer.textContent.slice(-30)}"`);
                                } else {
                                     console.log("TreeWalker did not find a preceding non-empty text node.");
                                }
                            }
                            // --- MODIFICATION END ---


                            // --- Proceed only if we found a valid target ---
                            if (targetContainer && targetContainer.nodeType === Node.TEXT_NODE && targetOffset > 0) {
                                const text = targetContainer.textContent || '';
                                console.log(`Operating on text: "${text.substring(0, 20)}...", Offset: ${targetOffset}`);

                                // Find word boundaries (logic remains the same, uses targetContainer/Offset)
                                let effectiveOffset = targetOffset;
                                while (effectiveOffset > 0 && (text[effectiveOffset - 1] === ' ' || text[effectiveOffset - 1] === '\n')) { effectiveOffset--; }
                                let wordStart = effectiveOffset;
                                if (effectiveOffset > 0) { while (wordStart > 0 && /\w/.test(text[wordStart - 1])) { wordStart--; } }
                                else { wordStart = 0; }

                                if (wordStart < effectiveOffset) {
                                    const wordRange = document.createRange();
                                    wordRange.setStart(targetContainer, wordStart);
                                    wordRange.setEnd(targetContainer, effectiveOffset);

                                    // Check if already deleted
                                    let parent = targetContainer.parentNode;
                                    let isAlreadyDeleted = false;
                                    while(parent && parent !== editor) { if (parent.nodeName === 'DEL') { isAlreadyDeleted = true; break; } parent = parent.parentNode; }
                                    if (!isAlreadyDeleted && wordRange.startContainer.previousSibling && wordRange.startContainer.previousSibling.nodeName === 'DEL' && wordRange.startOffset === 0) { /* Edge case */ }
                                    else if (!isAlreadyDeleted && targetContainer.parentNode.nodeName === 'DEL') { isAlreadyDeleted = true; }

                                    if (!isAlreadyDeleted) {
                                        // Apply strikethrough
                                        const contents = wordRange.extractContents();
                                        const delElement = document.createElement('del');
                                        delElement.appendChild(contents);
                                        wordRange.insertNode(delElement);

                                        // Position cursor using ZWS
                                        const parentNode = delElement.parentNode;
                                        if (parentNode) {
                                            const zwsNode = document.createTextNode('\u200B');
                                            parentNode.insertBefore(zwsNode, delElement.nextSibling);
                                            const cursorRange = document.createRange();
                                            cursorRange.setStart(zwsNode, 1);
                                            cursorRange.collapse(true);
                                            selection.removeAllRanges();
                                            selection.addRange(cursorRange);
                                        } else {
                                             console.error("Could not find parent node to insert ZWS.");
                                             const fallbackRange = document.createRange(); fallbackRange.setStartAfter(delElement); fallbackRange.collapse(true); selection.removeAllRanges(); selection.addRange(fallbackRange);
                                        }
                                        editor.dispatchEvent(new Event('input', { bubbles: true }));
                                        console.log("Struck out word.");
                                    } else { console.log("Word already struck out or cursor in ambiguous position."); }
                                } else { console.log("No word found before cursor (or only spaces found)."); }
                            } else { console.log("Could not find suitable text node or position to apply strikethrough."); }
                        } else { console.log("Selection is not collapsed or invalid."); }
                    } catch (e) { console.error("Error applying strikethrough:", e); }
                    lastBackspaceTime = 0; // Reset timer
                } else {
                    lastBackspaceTime = currentTime; // Update time
                    console.log("Single Backspace press detected - timer started.");
                }
                 return; // Stop processing
            }

            // --- Reset backspace timer ---
            lastBackspaceTime = 0;

        }); // End keydown listener

        // --- Save to Local Storage ---
        editor.addEventListener('input', function() {
            localStorage.setItem(localStorageKey, editor.innerHTML);
            console.log("Content saved to local storage.");
        });

    </script>
</body>
</html>
